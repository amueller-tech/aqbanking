/**********************************************************
 * This file has been automatically created by "typemaker2"
 * from the file "document.xml".
 * Please do not edit this file, all changes will be lost.
 * Better edit the mentioned source file instead.
 **********************************************************/

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include "document_p.h"

#include <gwenhywfar/misc.h>
#include <gwenhywfar/debug.h>

/* code headers */

/* macro functions */
GWEN_LIST_FUNCTIONS(AB_DOCUMENT, AB_Document)
GWEN_LIST2_FUNCTIONS(AB_DOCUMENT, AB_Document)


AB_DOCUMENT *AB_Document_new(void) {
  AB_DOCUMENT *p_struct;

  GWEN_NEW_OBJECT(AB_DOCUMENT, p_struct)
  p_struct->_refCount=1;
  GWEN_LIST_INIT(AB_DOCUMENT, p_struct)
  /* members */
  p_struct->id=NULL;
  p_struct->ownerId=0;
  p_struct->mimeType=NULL;
  p_struct->data.pointer=NULL; p_struct->data.length=0;
  /* virtual functions */

  return p_struct;
}

void AB_Document_free(AB_DOCUMENT *p_struct) {
  if (p_struct) {
  assert(p_struct->_refCount);
  if (p_struct->_refCount==1) {
    GWEN_LIST_FINI(AB_DOCUMENT, p_struct)
  /* members */
    free(p_struct->id);
    free(p_struct->mimeType);
    if (p_struct->data.length && p_struct->data.pointer) { free(p_struct->data.pointer); p_struct->data.pointer=NULL; p_struct->data.length=0; }
    p_struct->_refCount=0;
    GWEN_FREE_OBJECT(p_struct);
  }
  else
    p_struct->_refCount--;
  }
}

void AB_Document_Attach(AB_DOCUMENT *p_struct) {
  assert(p_struct);
  assert(p_struct->_refCount);
  p_struct->_refCount++;
}

AB_DOCUMENT *AB_Document_dup(const AB_DOCUMENT *p_src) {
  AB_DOCUMENT *p_struct;

  assert(p_src);
  p_struct=AB_Document_new();
  /* member "id" */
  if (p_struct->id) {
    free(p_struct->id);
    p_struct->id=NULL;
  }
  if (p_src->id) {
    p_struct->id=strdup(p_src->id);
  }

  /* member "ownerId" */
  p_struct->ownerId=p_src->ownerId;

  /* member "mimeType" */
  if (p_struct->mimeType) {
    free(p_struct->mimeType);
    p_struct->mimeType=NULL;
  }
  if (p_src->mimeType) {
    p_struct->mimeType=strdup(p_src->mimeType);
  }

  /* member "data" */
  if (p_src->data.length && p_src->data.pointer) { p_struct->data.pointer=(uint8_t*) malloc(p_src->data.length); if (p_struct->data.pointer) { p_struct->data.length=p_src->data.length; memmove(p_struct->data.pointer, p_src->data.pointer, p_src->data.length); } else { p_struct->data.pointer=NULL; p_struct->data.length=0; } } else { p_struct->data.pointer=NULL; p_struct->data.length=0; }

  return p_struct;
}

AB_DOCUMENT *AB_Document_copy(AB_DOCUMENT *p_struct, const AB_DOCUMENT *p_src) {
    assert(p_struct);
  assert(p_src);
  /* member "id" */
  if (p_struct->id) {
    free(p_struct->id);
    p_struct->id=NULL;
  }
  if (p_src->id) {
    p_struct->id=strdup(p_src->id);
  }

  /* member "ownerId" */
  p_struct->ownerId=p_src->ownerId;

  /* member "mimeType" */
  if (p_struct->mimeType) {
    free(p_struct->mimeType);
    p_struct->mimeType=NULL;
  }
  if (p_src->mimeType) {
    p_struct->mimeType=strdup(p_src->mimeType);
  }

  /* member "data" */
  if (p_src->data.length && p_src->data.pointer) { p_struct->data.pointer=(uint8_t*) malloc(p_src->data.length); if (p_struct->data.pointer) { p_struct->data.length=p_src->data.length; memmove(p_struct->data.pointer, p_src->data.pointer, p_src->data.length); } else { p_struct->data.pointer=NULL; p_struct->data.length=0; } } else { p_struct->data.pointer=NULL; p_struct->data.length=0; }

  return p_struct;
}

const char *AB_Document_GetId(const AB_DOCUMENT *p_struct) {
  assert(p_struct);
  return p_struct->id;
}

uint32_t AB_Document_GetOwnerId(const AB_DOCUMENT *p_struct) {
  assert(p_struct);
  return p_struct->ownerId;
}

const char *AB_Document_GetMimeType(const AB_DOCUMENT *p_struct) {
  assert(p_struct);
  return p_struct->mimeType;
}

GWEN_BINDATA AB_Document_GetData(const AB_DOCUMENT *p_struct) {
  assert(p_struct);
  return p_struct->data;
}

void AB_Document_SetId(AB_DOCUMENT *p_struct, const char *p_src) {
  assert(p_struct);
  if (p_struct->id) {
    free(p_struct->id);
  }
  if (p_src) {
    p_struct->id=strdup(p_src);
  }
  else {
    p_struct->id=NULL;
  }
}

void AB_Document_SetOwnerId(AB_DOCUMENT *p_struct, uint32_t p_src) {
  assert(p_struct);
  p_struct->ownerId=p_src;
}

void AB_Document_SetMimeType(AB_DOCUMENT *p_struct, const char *p_src) {
  assert(p_struct);
  if (p_struct->mimeType) {
    free(p_struct->mimeType);
  }
  if (p_src) {
    p_struct->mimeType=strdup(p_src);
  }
  else {
    p_struct->mimeType=NULL;
  }
}

void AB_Document_SetData(AB_DOCUMENT *p_struct, GWEN_BINDATA p_src) {
  assert(p_struct);
    if (p_struct->data.length && p_struct->data.pointer) { free(p_struct->data.pointer); p_struct->data.pointer=NULL; p_struct->data.length=0; }
    if (p_src.length && p_src.pointer) { p_struct->data.pointer=(uint8_t*) malloc(p_src.length); if (p_struct->data.pointer) { p_struct->data.length=p_src.length; memmove(p_struct->data.pointer, p_src.pointer, p_src.length); } else { p_struct->data.pointer=NULL; p_struct->data.length=0; } } else { p_struct->data.pointer=NULL; p_struct->data.length=0; }
}

/* list1 functions */
AB_DOCUMENT_LIST *AB_Document_List_dup(const AB_DOCUMENT_LIST *p_src) {
  AB_DOCUMENT_LIST *p_dest;
  AB_DOCUMENT *p_elem;

  assert(p_src);
  p_dest=AB_Document_List_new();
  p_elem=AB_Document_List_First(p_src);
  while(p_elem) {
    AB_DOCUMENT *p_cpy;

    p_cpy=AB_Document_dup(p_elem);
    AB_Document_List_Add(p_cpy, p_dest);
    p_elem=AB_Document_List_Next(p_elem);
  }

  return p_dest;
}

void AB_Document_ReadDb(AB_DOCUMENT *p_struct, GWEN_DB_NODE *p_db) {
  assert(p_struct);
  /* member "id" */
  if (p_struct->id) {
    free(p_struct->id);
  }
  { const char *s; s=GWEN_DB_GetCharValue(p_db, "id", 0, NULL); if (s) p_struct->id=strdup(s); }
  if (p_struct->id==NULL) {  p_struct->id=NULL;
  }

  /* member "ownerId" */
  p_struct->ownerId=GWEN_DB_GetIntValue(p_db, "ownerId", 0, 0);

  /* member "mimeType" */
  if (p_struct->mimeType) {
    free(p_struct->mimeType);
  }
  { const char *s; s=GWEN_DB_GetCharValue(p_db, "mimeType", 0, NULL); if (s) p_struct->mimeType=strdup(s); }
  if (p_struct->mimeType==NULL) {  p_struct->mimeType=NULL;
  }

  /* member "data" */
  { const void *v; unsigned int vlen; v=GWEN_DB_GetBinValue(p_db, "data", 0, NULL, 0, &vlen); if (v && vlen) { uint8_t *dest; dest=(uint8_t*) malloc(vlen); memmove(dest, v, vlen); p_struct->data.pointer=dest; p_struct->data.length=vlen; } }

}

int AB_Document_WriteDb(const AB_DOCUMENT *p_struct, GWEN_DB_NODE *p_db) {
  int p_rv;

  assert(p_struct);
  /* member "id" */
  if (p_struct->id) p_rv=GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "id", p_struct->id); else { GWEN_DB_DeleteVar(p_db, "id"); p_rv=0; }
  if (p_rv<0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "ownerId" */
  p_rv=GWEN_DB_SetIntValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "ownerId", p_struct->ownerId);
  if (p_rv<0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "mimeType" */
  if (p_struct->mimeType) p_rv=GWEN_DB_SetCharValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "mimeType", p_struct->mimeType); else { GWEN_DB_DeleteVar(p_db, "mimeType"); p_rv=0; }
  if (p_rv<0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  /* member "data" */
  { if (p_struct->data.length && p_struct->data.pointer) { GWEN_DB_SetBinValue(p_db, GWEN_DB_FLAGS_OVERWRITE_VARS, "data", p_struct->data.pointer, p_struct->data.length); } else { GWEN_DB_DeleteVar(p_db, "data"); p_rv=0; } }
  if (p_rv<0) {
    DBG_INFO(GWEN_LOGDOMAIN, "here (%d)\n", p_rv);
    return p_rv;
  }

  return 0;
}

AB_DOCUMENT *AB_Document_fromDb(GWEN_DB_NODE *p_db) {
  AB_DOCUMENT *p_struct;
  p_struct=AB_Document_new();
  AB_Document_ReadDb(p_struct, p_db);
  return p_struct;
}

int AB_Document_toDb(const AB_DOCUMENT *p_struct, GWEN_DB_NODE *p_db) {
  return AB_Document_WriteDb(p_struct, p_db);
}

void AB_Document_ReadXml(AB_DOCUMENT *p_struct, GWEN_XMLNODE *p_db) {
  assert(p_struct);
  /* member "id" */
  if (p_struct->id) {
    free(p_struct->id);
  }
  { const char *s; s=GWEN_XMLNode_GetCharValue(p_db, "id", NULL); if (s) p_struct->id=strdup(s); }
  if (p_struct->id==NULL) {  /* preset member "id" if empty */
  p_struct->id=NULL;
  }

  /* member "ownerId" */
  p_struct->ownerId=GWEN_XMLNode_GetIntValue(p_db, "ownerId", 0);

  /* member "mimeType" */
  if (p_struct->mimeType) {
    free(p_struct->mimeType);
  }
  { const char *s; s=GWEN_XMLNode_GetCharValue(p_db, "mimeType", NULL); if (s) p_struct->mimeType=strdup(s); }
  if (p_struct->mimeType==NULL) {  /* preset member "mimeType" if empty */
  p_struct->mimeType=NULL;
  }

  /* member "data" */
  { const char *s; s=GWEN_XMLNode_GetCharValue(p_db, "data", NULL); if (s) { GWEN_BUFFER *tbuf; int rv; tbuf=GWEN_Buffer_new(0, 1024, 0, 1); rv=GWEN_Base64_Decode((const unsigned char*)s, strlen(s), tbuf); if (rv < 0) { DBG_INFO(GWEN_LOGDOMAIN, "here (%d)", rv); } else { char *t; uint32_t len; len=GWEN_Buffer_GetUsedBytes(tbuf); t=GWEN_Buffer_GetStart(tbuf); if (GWEN_Buffer_Relinquish(tbuf) < 0) { uint8_t *dest; dest=(uint8_t*) malloc(len); memmove(dest, t, len); p_struct->data.pointer=dest; p_struct->data.length=len; } else { p_struct->data.pointer=(uint8_t*) t; p_struct->data.length=len; } } GWEN_Buffer_free(tbuf); } }

}

void AB_Document_WriteXml(const AB_DOCUMENT *p_struct, GWEN_XMLNODE *p_db) {
  assert(p_struct);
  /* member "id" */
  GWEN_XMLNode_SetCharValue(p_db, "id", p_struct->id);

  /* member "ownerId" */
  GWEN_XMLNode_SetIntValue(p_db, "ownerId", p_struct->ownerId);

  /* member "mimeType" */
  GWEN_XMLNode_SetCharValue(p_db, "mimeType", p_struct->mimeType);

  /* member "data" */
  { if (p_struct->data.length && p_struct->data.pointer) { GWEN_BUFFER *tbuf; int rv; tbuf=GWEN_Buffer_new(0, 1024, 0, 1); rv=GWEN_Base64_Encode((const unsigned char*) p_struct->data.pointer, p_struct->data.length, tbuf, 80); if (rv < 0) { DBG_INFO(GWEN_LOGDOMAIN, "here (%d)", rv); } else { GWEN_XMLNode_SetCharValue(p_db, "data", GWEN_Buffer_GetStart(tbuf)); GWEN_Buffer_free(tbuf); } } }

}

void AB_Document_toXml(const AB_DOCUMENT *p_struct, GWEN_XMLNODE *p_db) {
  AB_Document_WriteXml(p_struct, p_db);
}

AB_DOCUMENT *AB_Document_fromXml(GWEN_XMLNODE *p_db) {
  AB_DOCUMENT *p_struct;
  p_struct=AB_Document_new();
  AB_Document_ReadXml(p_struct, p_db);
  return p_struct;
}

static AB_DOCUMENT *AB_Document_List2__freeAll_cb(AB_DOCUMENT *t, void *user_data) { AB_Document_free(t); return NULL; } int AB_Document_List2_freeAll(AB_DOCUMENT_LIST2 *tl) { if (tl) { AB_Document_List2_ForEach(tl, AB_Document_List2__freeAll_cb, NULL); AB_Document_List2_free(tl); } else { DBG_ERROR(AQBANKING_LOGDOMAIN, "List missing"); return GWEN_ERROR_INVALID; } return 0; }

/* code headers */

