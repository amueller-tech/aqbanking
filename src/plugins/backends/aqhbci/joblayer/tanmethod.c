/* This file is auto-generated from "tanmethod.xml" by the typemaker
   tool of Gwenhywfar. 
   Do not edit this file -- all changes will be lost! */
#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include "tanmethod_p.h"
#include <gwenhywfar/misc.h>
#include <gwenhywfar/db.h>
#include <gwenhywfar/debug.h>
#include <assert.h>
#include <stdlib.h>
#include <strings.h>

GWEN_INHERIT_FUNCTIONS(AH_TAN_METHOD)
GWEN_LIST_FUNCTIONS(AH_TAN_METHOD, AH_TanMethod)
GWEN_LIST2_FUNCTIONS(AH_TAN_METHOD, AH_TanMethod)




AH_TAN_METHOD *AH_TanMethod_new() {
  AH_TAN_METHOD *st;

  GWEN_NEW_OBJECT(AH_TAN_METHOD, st)
  st->_usage=1;
  GWEN_INHERIT_INIT(AH_TAN_METHOD, st)
  GWEN_LIST_INIT(AH_TAN_METHOD, st)
  return st;
}


void AH_TanMethod_free(AH_TAN_METHOD *st) {
  if (st) {
    assert(st->_usage);
    if (--(st->_usage)==0) {
  GWEN_INHERIT_FINI(AH_TAN_METHOD, st)
  if (st->methodId)
    free(st->methodId);
  if (st->methodName)
    free(st->methodName);
  if (st->zkaTanName)
    free(st->zkaTanName);
  if (st->zkaTanVersion)
    free(st->zkaTanVersion);
  if (st->formatId)
    free(st->formatId);
  if (st->prompt)
    free(st->prompt);
  GWEN_LIST_FINI(AH_TAN_METHOD, st)
  GWEN_FREE_OBJECT(st);
    }
  }

}


AH_TAN_METHOD *AH_TanMethod_dup(const AH_TAN_METHOD *d) {
  AH_TAN_METHOD *st;

  assert(d);
  st=AH_TanMethod_new();
  st->function=d->function;
  st->process=d->process;
  if (d->methodId)
    st->methodId=strdup(d->methodId);
  if (d->methodName)
    st->methodName=strdup(d->methodName);
  if (d->zkaTanName)
    st->zkaTanName=strdup(d->zkaTanName);
  if (d->zkaTanVersion)
    st->zkaTanVersion=strdup(d->zkaTanVersion);
  st->tanMaxLen=d->tanMaxLen;
  if (d->formatId)
    st->formatId=strdup(d->formatId);
  if (d->prompt)
    st->prompt=strdup(d->prompt);
  st->returnMaxLen=d->returnMaxLen;
  st->maxActiveLists=d->maxActiveLists;
  st->multiTanAllowed=d->multiTanAllowed;
  st->timeShiftAllowed=d->timeShiftAllowed;
  st->tanListMode=d->tanListMode;
  st->stornoAllowed=d->stornoAllowed;
  st->needSmsAccount=d->needSmsAccount;
  st->needLocalAccount=d->needLocalAccount;
  st->needChallengeClass=d->needChallengeClass;
  st->needChallengeAmount=d->needChallengeAmount;
  st->challengeIsStructured=d->challengeIsStructured;
  st->initMode=d->initMode;
  st->needTanMediumId=d->needTanMediumId;
  st->maxActiveTanMedia=d->maxActiveTanMedia;
  st->gvVersion=d->gvVersion;
  return st;
}


int AH_TanMethod_toDb(const AH_TAN_METHOD *st, GWEN_DB_NODE *db) {
  assert(st);
  assert(db);
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "function", st->function))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "process", st->process))
    return -1;
  if (st->methodId)
    if (GWEN_DB_SetCharValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "methodId", st->methodId))
      return -1;
  if (st->methodName)
    if (GWEN_DB_SetCharValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "methodName", st->methodName))
      return -1;
  if (st->zkaTanName)
    if (GWEN_DB_SetCharValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "zkaTanName", st->zkaTanName))
      return -1;
  if (st->zkaTanVersion)
    if (GWEN_DB_SetCharValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "zkaTanVersion", st->zkaTanVersion))
      return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "tanMaxLen", st->tanMaxLen))
    return -1;
  if (st->formatId)
    if (GWEN_DB_SetCharValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "formatId", st->formatId))
      return -1;
  if (st->prompt)
    if (GWEN_DB_SetCharValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "prompt", st->prompt))
      return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "returnMaxLen", st->returnMaxLen))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "maxActiveLists", st->maxActiveLists))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "multiTanAllowed", st->multiTanAllowed))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "timeShiftAllowed", st->timeShiftAllowed))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "tanListMode", st->tanListMode))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "stornoAllowed", st->stornoAllowed))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "needSmsAccount", st->needSmsAccount))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "needLocalAccount", st->needLocalAccount))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "needChallengeClass", st->needChallengeClass))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "needChallengeAmount", st->needChallengeAmount))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "challengeIsStructured", st->challengeIsStructured))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "initMode", st->initMode))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "needTanMediumId", st->needTanMediumId))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "maxActiveTanMedia", st->maxActiveTanMedia))
    return -1;
  if (GWEN_DB_SetIntValue(db, GWEN_DB_FLAGS_OVERWRITE_VARS, "gvVersion", st->gvVersion))
    return -1;
  return 0;
}


int AH_TanMethod_ReadDb(AH_TAN_METHOD *st, GWEN_DB_NODE *db) {
  assert(st);
  assert(db);
  AH_TanMethod_SetFunction(st, GWEN_DB_GetIntValue(db, "function", 0, 0));
  AH_TanMethod_SetProcess(st, GWEN_DB_GetIntValue(db, "process", 0, 0));
  AH_TanMethod_SetMethodId(st, GWEN_DB_GetCharValue(db, "methodId", 0, 0));
  AH_TanMethod_SetMethodName(st, GWEN_DB_GetCharValue(db, "methodName", 0, 0));
  AH_TanMethod_SetZkaTanName(st, GWEN_DB_GetCharValue(db, "zkaTanName", 0, 0));
  AH_TanMethod_SetZkaTanVersion(st, GWEN_DB_GetCharValue(db, "zkaTanVersion", 0, 0));
  AH_TanMethod_SetTanMaxLen(st, GWEN_DB_GetIntValue(db, "tanMaxLen", 0, 0));
  AH_TanMethod_SetFormatId(st, GWEN_DB_GetCharValue(db, "formatId", 0, 0));
  AH_TanMethod_SetPrompt(st, GWEN_DB_GetCharValue(db, "prompt", 0, 0));
  AH_TanMethod_SetReturnMaxLen(st, GWEN_DB_GetIntValue(db, "returnMaxLen", 0, 0));
  AH_TanMethod_SetMaxActiveLists(st, GWEN_DB_GetIntValue(db, "maxActiveLists", 0, 0));
  AH_TanMethod_SetMultiTanAllowed(st, GWEN_DB_GetIntValue(db, "multiTanAllowed", 0, 0));
  AH_TanMethod_SetTimeShiftAllowed(st, GWEN_DB_GetIntValue(db, "timeShiftAllowed", 0, 0));
  AH_TanMethod_SetTanListMode(st, GWEN_DB_GetIntValue(db, "tanListMode", 0, 0));
  AH_TanMethod_SetStornoAllowed(st, GWEN_DB_GetIntValue(db, "stornoAllowed", 0, 0));
  AH_TanMethod_SetNeedSmsAccount(st, GWEN_DB_GetIntValue(db, "needSmsAccount", 0, 0));
  AH_TanMethod_SetNeedLocalAccount(st, GWEN_DB_GetIntValue(db, "needLocalAccount", 0, 0));
  AH_TanMethod_SetNeedChallengeClass(st, GWEN_DB_GetIntValue(db, "needChallengeClass", 0, 0));
  AH_TanMethod_SetNeedChallengeAmount(st, GWEN_DB_GetIntValue(db, "needChallengeAmount", 0, 0));
  AH_TanMethod_SetChallengeIsStructured(st, GWEN_DB_GetIntValue(db, "challengeIsStructured", 0, 0));
  AH_TanMethod_SetInitMode(st, GWEN_DB_GetIntValue(db, "initMode", 0, 0));
  AH_TanMethod_SetNeedTanMediumId(st, GWEN_DB_GetIntValue(db, "needTanMediumId", 0, 0));
  AH_TanMethod_SetMaxActiveTanMedia(st, GWEN_DB_GetIntValue(db, "maxActiveTanMedia", 0, 0));
  AH_TanMethod_SetGvVersion(st, GWEN_DB_GetIntValue(db, "gvVersion", 0, 0));
  return 0;
}


AH_TAN_METHOD *AH_TanMethod_fromDb(GWEN_DB_NODE *db) {
  AH_TAN_METHOD *st;

  assert(db);
  st=AH_TanMethod_new();
  AH_TanMethod_ReadDb(st, db);
  st->_modified=0;
  return st;
}




int AH_TanMethod_GetFunction(const AH_TAN_METHOD *st) {
  assert(st);
  return st->function;
}


void AH_TanMethod_SetFunction(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->function=d;
  st->_modified=1;
}




int AH_TanMethod_GetProcess(const AH_TAN_METHOD *st) {
  assert(st);
  return st->process;
}


void AH_TanMethod_SetProcess(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->process=d;
  st->_modified=1;
}




const char *AH_TanMethod_GetMethodId(const AH_TAN_METHOD *st) {
  assert(st);
  return st->methodId;
}


void AH_TanMethod_SetMethodId(AH_TAN_METHOD *st, const char *d) {
  assert(st);
  if (st->methodId)
    free(st->methodId);
  if (d && *d)
    st->methodId=strdup(d);
  else
    st->methodId=0;
  st->_modified=1;
}




const char *AH_TanMethod_GetMethodName(const AH_TAN_METHOD *st) {
  assert(st);
  return st->methodName;
}


void AH_TanMethod_SetMethodName(AH_TAN_METHOD *st, const char *d) {
  assert(st);
  if (st->methodName)
    free(st->methodName);
  if (d && *d)
    st->methodName=strdup(d);
  else
    st->methodName=0;
  st->_modified=1;
}




const char *AH_TanMethod_GetZkaTanName(const AH_TAN_METHOD *st) {
  assert(st);
  return st->zkaTanName;
}


void AH_TanMethod_SetZkaTanName(AH_TAN_METHOD *st, const char *d) {
  assert(st);
  if (st->zkaTanName)
    free(st->zkaTanName);
  if (d && *d)
    st->zkaTanName=strdup(d);
  else
    st->zkaTanName=0;
  st->_modified=1;
}




const char *AH_TanMethod_GetZkaTanVersion(const AH_TAN_METHOD *st) {
  assert(st);
  return st->zkaTanVersion;
}


void AH_TanMethod_SetZkaTanVersion(AH_TAN_METHOD *st, const char *d) {
  assert(st);
  if (st->zkaTanVersion)
    free(st->zkaTanVersion);
  if (d && *d)
    st->zkaTanVersion=strdup(d);
  else
    st->zkaTanVersion=0;
  st->_modified=1;
}




int AH_TanMethod_GetTanMaxLen(const AH_TAN_METHOD *st) {
  assert(st);
  return st->tanMaxLen;
}


void AH_TanMethod_SetTanMaxLen(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->tanMaxLen=d;
  st->_modified=1;
}




const char *AH_TanMethod_GetFormatId(const AH_TAN_METHOD *st) {
  assert(st);
  return st->formatId;
}


void AH_TanMethod_SetFormatId(AH_TAN_METHOD *st, const char *d) {
  assert(st);
  if (st->formatId)
    free(st->formatId);
  if (d && *d)
    st->formatId=strdup(d);
  else
    st->formatId=0;
  st->_modified=1;
}




const char *AH_TanMethod_GetPrompt(const AH_TAN_METHOD *st) {
  assert(st);
  return st->prompt;
}


void AH_TanMethod_SetPrompt(AH_TAN_METHOD *st, const char *d) {
  assert(st);
  if (st->prompt)
    free(st->prompt);
  if (d && *d)
    st->prompt=strdup(d);
  else
    st->prompt=0;
  st->_modified=1;
}




int AH_TanMethod_GetReturnMaxLen(const AH_TAN_METHOD *st) {
  assert(st);
  return st->returnMaxLen;
}


void AH_TanMethod_SetReturnMaxLen(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->returnMaxLen=d;
  st->_modified=1;
}




int AH_TanMethod_GetMaxActiveLists(const AH_TAN_METHOD *st) {
  assert(st);
  return st->maxActiveLists;
}


void AH_TanMethod_SetMaxActiveLists(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->maxActiveLists=d;
  st->_modified=1;
}




int AH_TanMethod_GetMultiTanAllowed(const AH_TAN_METHOD *st) {
  assert(st);
  return st->multiTanAllowed;
}


void AH_TanMethod_SetMultiTanAllowed(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->multiTanAllowed=d;
  st->_modified=1;
}




int AH_TanMethod_GetTimeShiftAllowed(const AH_TAN_METHOD *st) {
  assert(st);
  return st->timeShiftAllowed;
}


void AH_TanMethod_SetTimeShiftAllowed(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->timeShiftAllowed=d;
  st->_modified=1;
}




int AH_TanMethod_GetTanListMode(const AH_TAN_METHOD *st) {
  assert(st);
  return st->tanListMode;
}


void AH_TanMethod_SetTanListMode(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->tanListMode=d;
  st->_modified=1;
}




int AH_TanMethod_GetStornoAllowed(const AH_TAN_METHOD *st) {
  assert(st);
  return st->stornoAllowed;
}


void AH_TanMethod_SetStornoAllowed(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->stornoAllowed=d;
  st->_modified=1;
}




int AH_TanMethod_GetNeedSmsAccount(const AH_TAN_METHOD *st) {
  assert(st);
  return st->needSmsAccount;
}


void AH_TanMethod_SetNeedSmsAccount(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->needSmsAccount=d;
  st->_modified=1;
}




int AH_TanMethod_GetNeedLocalAccount(const AH_TAN_METHOD *st) {
  assert(st);
  return st->needLocalAccount;
}


void AH_TanMethod_SetNeedLocalAccount(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->needLocalAccount=d;
  st->_modified=1;
}




int AH_TanMethod_GetNeedChallengeClass(const AH_TAN_METHOD *st) {
  assert(st);
  return st->needChallengeClass;
}


void AH_TanMethod_SetNeedChallengeClass(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->needChallengeClass=d;
  st->_modified=1;
}




int AH_TanMethod_GetNeedChallengeAmount(const AH_TAN_METHOD *st) {
  assert(st);
  return st->needChallengeAmount;
}


void AH_TanMethod_SetNeedChallengeAmount(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->needChallengeAmount=d;
  st->_modified=1;
}




int AH_TanMethod_GetChallengeIsStructured(const AH_TAN_METHOD *st) {
  assert(st);
  return st->challengeIsStructured;
}


void AH_TanMethod_SetChallengeIsStructured(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->challengeIsStructured=d;
  st->_modified=1;
}




int AH_TanMethod_GetInitMode(const AH_TAN_METHOD *st) {
  assert(st);
  return st->initMode;
}


void AH_TanMethod_SetInitMode(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->initMode=d;
  st->_modified=1;
}




int AH_TanMethod_GetNeedTanMediumId(const AH_TAN_METHOD *st) {
  assert(st);
  return st->needTanMediumId;
}


void AH_TanMethod_SetNeedTanMediumId(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->needTanMediumId=d;
  st->_modified=1;
}




int AH_TanMethod_GetMaxActiveTanMedia(const AH_TAN_METHOD *st) {
  assert(st);
  return st->maxActiveTanMedia;
}


void AH_TanMethod_SetMaxActiveTanMedia(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->maxActiveTanMedia=d;
  st->_modified=1;
}




int AH_TanMethod_GetGvVersion(const AH_TAN_METHOD *st) {
  assert(st);
  return st->gvVersion;
}


void AH_TanMethod_SetGvVersion(AH_TAN_METHOD *st, int d) {
  assert(st);
  st->gvVersion=d;
  st->_modified=1;
}




int AH_TanMethod_IsModified(const AH_TAN_METHOD *st) {
  assert(st);
  return st->_modified;
}


void AH_TanMethod_SetModified(AH_TAN_METHOD *st, int i) {
  assert(st);
  st->_modified=i;
}


void AH_TanMethod_Attach(AH_TAN_METHOD *st) {
  assert(st);
  st->_usage++;
}
AH_TAN_METHOD *AH_TanMethod_List2__freeAll_cb(AH_TAN_METHOD *st, void *user_data) {
  AH_TanMethod_free(st);
return 0;
}


void AH_TanMethod_List2_freeAll(AH_TAN_METHOD_LIST2 *stl) {
  if (stl) {
    AH_TanMethod_List2_ForEach(stl, AH_TanMethod_List2__freeAll_cb, 0);
    AH_TanMethod_List2_free(stl); 
  }
}


AH_TAN_METHOD_LIST *AH_TanMethod_List_dup(const AH_TAN_METHOD_LIST *stl) {
  if (stl) {
    AH_TAN_METHOD_LIST *nl;
    AH_TAN_METHOD *e;

    nl=AH_TanMethod_List_new();
    e=AH_TanMethod_List_First(stl);
    while(e) {
      AH_TAN_METHOD *ne;

      ne=AH_TanMethod_dup(e);
      assert(ne);
      AH_TanMethod_List_Add(ne, nl);
      e=AH_TanMethod_List_Next(e);
    } /* while (e) */
    return nl;
  }
  else
    return 0;
}




